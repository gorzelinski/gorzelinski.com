---
title: NajwiÄ™kszy problem w projektowaniu oprogramowania
description: 'Dowiedz siÄ™ jak rozpoznawaÄ‡ i adresowaÄ‡ popularne puÅ‚apki w projektowaniu oprogramowania. Zobacz, jak dobre projektowanie moÅ¼e prowadziÄ‡ do prostszego i bardziej niezawodnego kodu.'
date: 2025-05-10T11:00:00+02:00
updated: 2025-05-10T11:00:00+02:00
image:
  alt: 'PoplÄ…tany zbiÃ³r wÅ‚Ã³kien na biaÅ‚ym tle'
  caption: 'ZdjÄ™cie autorstwa Kier in Sight Archives'
  src: 'kier-in-sight-archives-4bhhwmsYl-c-unsplash.jpg'
categories: ['informatyka', 'rozwÃ³j sieci']
tags: ['software', 'design', 'zÅ‚oÅ¼onoÅ›Ä‡', 'programowanie', 'moduÅ‚y']
type: 'post'
---

> Najbardziej fundamentalnym problemem w informatyce jest **problem dekompozycji:** jak wziÄ…Ä‡ zÅ‚oÅ¼ony problem i podzieliÄ‡ go na czÄ™Å›ci, ktÃ³re mogÄ… byÄ‡ rozwiÄ…zane niezaleÅ¼nie.

Jest to jedno z wprowadzajÄ…cych zdaÅ„ w ksiÄ…Å¼ce John'a Ousterhoust'a, "A Philosophy of Software Design". Autor argumentuje, Å¼e w projektowaniu oprogramowania chodzi gÅ‚Ã³wnie o zÅ‚oÅ¼onoÅ›Ä‡. Jako programiÅ›ci, ciÄ…gle walczymy ze zÅ‚oÅ¼onoÅ›ciÄ…. PowinniÅ›my jÄ… przestudiowaÄ‡, rozpoznaÄ‡ jej przyczyny i nauczyÄ‡ siÄ™ w jaki sposÃ³b jÄ… minimalizowaÄ‡. Nie powinniÅ›my siÄ™ skupiaÄ‡ tylko na nauce jÄ™zykÃ³w programowania, frameworkÃ³w, skÅ‚adni, ale takÅ¼e nauczyÄ‡ siÄ™ _jak projektowaÄ‡_ dobre oprogramowanie.

## Definicja zÅ‚oÅ¼onoÅ›ci

<Callout variant="info">

**ZÅ‚oÅ¼onoÅ›Ä‡**  
ZÅ‚oÅ¼onoÅ›Ä‡ to wszystko co wiÄ…Å¼e siÄ™ ze strukturÄ… oprogramowania, utrudniajÄ…ce zrozumienie i modyfikacje systemu.

</Callout>

Definicja jest klarowna. System oprogramowania jest zÅ‚oÅ¼ony, gdy jest trudny do zrozumienia i modyfikacji. Jestem pewien, Å¼e pracowaÅ‚eÅ› kiedyÅ› nad jakimÅ› przestarzaÅ‚ym kodzie spaghetti, wiÄ™c pewnie wiesz o czym mÃ³wiÄ™. JeÅ¼eli system jest Å‚atwy do zrozumienia i modyfikacji - nie jest zÅ‚oÅ¼ony.

OgÃ³lnie, moÅ¼emy zdefiniowaÄ‡ zÅ‚oÅ¼onoÅ›Ä‡ systemu uÅ¼ywajÄ…c nastÄ™pujÄ…cego rÃ³wnania (jest to jedyne rÃ³wnanie w caÅ‚ym wpisie, obiecujÄ™).

```math
C = \sum_{p}{c_p t_p}
```

- C - zÅ‚oÅ¼onoÅ›Ä‡ systemu
- c<sub>p</sub> - zÅ‚oÅ¼onoÅ›Ä‡ kaÅ¼dej czÄ™Å›ci
- t<sub>p</sub> - iloÅ›Ä‡ czasu jakÄ… programiÅ›ci spÄ™dzajÄ… pracujÄ…c nad danÄ… czÄ™Å›ciÄ…

CaÅ‚kowita zÅ‚oÅ¼onoÅ›Ä‡ systemu jest sumÄ… zÅ‚oÅ¼onoÅ›ci poszczegÃ³lnych czÄ™Å›ci. Konkretna czÄ™Å›Ä‡ jest bardziej zÅ‚oÅ¼ona, jeÅ¼eli programiÅ›ci poÅ›wiÄ™cajÄ… wiÄ™cej czasu na pracÄ™ z niÄ….

ZÅ‚oÅ¼onoÅ›Ä‡ jest bardziej widoczna dla czytelnika niÅ¼ dla pisarza kodu - podobnie do [standardowego pisania](/pl/blog/the-craft-of-writing). JeÅ¼eli kod wydaje siÄ™ prosty dla ciebie, ale taki nie jest dla czytelnika, wtedy najprawdopodobniej jest zÅ‚oÅ¼ony.

## Walka ze zÅ‚oÅ¼onoÅ›ciÄ…

Autor rozpoznaje dwa gÅ‚Ã³wne podejÅ›cia do walki ze zÅ‚oÅ¼onoÅ›ciÄ…:

1. Spraw, aby kod byÅ‚ prostszy i bardziej oczywisty.
2. Enkapsuluj, tak Å¼eby programiÅ›ci mogli pracowaÄ‡ nad systemem bez wystawiania ich na caÅ‚Ä… zÅ‚oÅ¼onoÅ›Ä‡.

Na poczÄ…tek, zobaczmy jak rozpoznawaÄ‡ zÅ‚oÅ¼onoÅ›Ä‡, zanim jej dotkniemy.

> Najlepszym sposobem, aby poprawiÄ‡ swoje zdolnoÅ›ci programowania to rozpoznawaÄ‡ czerwone flagi.

Czerwone flagi sÄ… czÄ™sto metaforÄ… na rozpoznawanie toksycznych zachowaÅ„ w ludziach. TwÃ³j najbliÅ¼szy przyjaciel nie jest szczery? Jest to prawdopodobnie czerwona flaga. Podobnie bÄ™dziemy prÃ³bowali zauwaÅ¼aÄ‡ czerwone flagi w kodzie. BÄ™dÄ™ o nich wspominaÅ‚ tu i tam w kolejnych paragrafach. Gdy rozpoznasz czerwonÄ… flagÄ™ w kodzie, jest to znak, Å¼e fragment kodu jest bardziej zÅ‚oÅ¼ony niÅ¼ byÄ‡ powinien - jest to czas na refaktoryzacjÄ™ czy przepisywanie. W ksiÄ…Å¼ce "Refaktoryzacja. Ulepszanie struktury istniejÄ…cego kodu.", Martin Fowler uÅ¼ywa terminu "zapaszki kodu". Idea jest podobna, ale ja bÄ™dÄ™ siÄ™ trzymaÅ‚ czerwonych flag i wykorzystam odpowiednie emoji ğŸš©

## Symptomy zÅ‚oÅ¼onoÅ›ci

Autor podkreÅ›la trzy, gÅ‚Ã³wne symptomy zÅ‚oÅ¼onoÅ›ci.

### Amplifikacja zmian

Pierwszym z nich jest **amplifikacja zmian.** Mamy do czynienia z amplifikacjÄ… zmian, gdy pozornie prosta zmiana wymaga modyfikacji kodu w wielu miejscach.

WyobraÅº sobie scenariusz, w ktÃ³rym masz witrynÄ™ internetowÄ… z wieloma stronami. Najprawdopodobniej byÅ‚yby tam jakieÅ› kolory i spÃ³jnoÅ›Ä‡. Zamiast uÅ¼ywaÄ‡ kolorÃ³w ad hoc, w stylu `color: hsl(210, 96%, 40%)`, moÅ¼esz zdefiniowaÄ‡ zmiennÄ… CSS i przypisaÄ‡ jej wartoÅ›Ä‡ `--color-primary-500: hsl(210, 96%, 40%)`. NastÄ™pnym razem, gdy jakiÅ› "stabilny geniusz" wymusi znaczÄ…cy rebranding na stronie, zmieniajÄ…c caÅ‚Ä… paletÄ™ kolorÃ³w, nie bÄ™dzie to problem - zmiany bÄ™dzie wymagaÅ‚a tylko wartoÅ›Ä‡ zmiennej, zamiast zmiany kolorÃ³w w wielu miejscach.

Celem dobrego designu jest redukcja iloÅ›ci kodu dotkniÄ™tego przez kaÅ¼dÄ… z projektowych decyzji, w taki sposÃ³b, Å¼e zmiany projektowy nie wymagajÄ… zmian kodu w wielu miejscach.

### ObciÄ…Å¼enie poznawcze

Drugim symptomem zÅ‚oÅ¼onoÅ›ci jest obciÄ…Å¼enie poznawcze. Odnosi siÄ™ ono do informacji i ograniczeÅ„ ludzkiego mÃ³zgu - jak wiele informacji programista potrzebuje wiedzieÄ‡, aby wykonaÄ‡ zadanie.

ObciÄ…Å¼enie poznawcze moÅ¼e pojawiÄ‡ siÄ™ na wiele sposobÃ³w:

- API z wieloma metodami
- globalne zmienne
- niespÃ³jnoÅ›ci
- zaleÅ¼noÅ›ci pomiÄ™dzy moduÅ‚ami
- jakiÅ› "magiczny kod" pod maskÄ…

WiÄ™ksze obciÄ…Å¼enie poznawcze oznacza, Å¼e programista musi spÄ™dziÄ‡ wiÄ™cej czasu na nauce niezbÄ™dnych informacji, zamiast dostarczaÄ‡ wartoÅ›Ä‡. Dodatkowo, istnieje wiÄ™ksze ryzyko pojawienia siÄ™ bÅ‚Ä™dÃ³w, bo mogÄ… pominÄ…Ä‡ coÅ› istotnego.

OczywiÅ›cie obciÄ…Å¼enie poznawcze nie jest Å›ciÅ›le powiÄ…zane z liczbÄ… linii kodu. Czasami podejÅ›cie, ktÃ³re wymaga wiÄ™cej lini kodu jest bardziej transparentne, poniewaÅ¼ redukuje obciÄ…Å¼enie. Zobacz na ten operator trÃ³jskÅ‚adnikowy zastÄ…piony przez instrukcje if.

```js title="Jednolinijkowy operator trÃ³jskÅ‚adnikowy"
// prettier-ignore
pet.canBark() ? pet.isScary() ? 'wolf' : 'dog' : pet.canMeow() ? 'cat' : 'probably a bunny'
```

```js title="Wieloliniowe instrukcje if"
if (pet.canBark() && pet.isScary()) {
  return 'wolf'
}
if (pet.canBark()) return 'dog'
if (pet.canMeow()) return 'cat'
else return 'probably a bunny'
```

### Nieznane nieznane

Ostatnia z trzech manifestacji zÅ‚oÅ¼onoÅ›ci jest najgorsza. Nieznane nieznane oznaczajÄ…, Å¼e nie jest oczywiste, ktÃ³re fragmenty kodu muszÄ… zostaÄ‡ zmodyfikowane, aby zakoÅ„czyÄ‡ zadanie lub ktÃ³re informacje musi posiadaÄ‡ programista, aby zakoÅ„czyÄ‡ zadanie.

Ta manifestacja nawiÄ…zuje do macierzy: Å›wiadomoÅ›Ä‡ - zrozumienie. Macierz ta pochodzi z konferencji prasowej z 2002 roku o wojnie w Iraku. Donald Rumsfled - sekretarz obrony StanÃ³w Zjednoczonych - podzieliÅ‚ informacje na cztery kategorie.

|             | Åšwiadomy       | NieÅ›wiadomy       |
| ----------- | -------------- | ----------------- |
| Rozumie     | Znane znane    | Nieznane znane    |
| Nie rozumie | Znane nieznane | Nieznane nieznane |

- **Znane znane** - fakty lub zmienne, o ktÃ³rych istnieniu jesteÅ›my Å›wiadomi i je rozumiemy.
- **Nieznane znane** - czynniki, o ktÃ³rych wiemy, Å¼e istniejÄ…, ale w peÅ‚ni ich nie rozumiemy.
- **Znane nieznane** - elementy z ktÃ³rych sobie nie zdajemy sprawy, Å¼e je wiemy.
- **Nieznane nieznane** - czynniki, ktÃ³rych nie jesteÅ›my Å›wiadomi i ktÃ³rych nie moÅ¼emy przewidzieÄ‡.

Åatwo sobie wyobraziÄ‡, Å¼e nieÅ›wiadomoÅ›Ä‡ niektÃ³rych mechanizmÃ³w systemu moÅ¼e prowadziÄ‡ do paskudnych bugÃ³w. Dlatego jednym z waÅ¼niejszych celÃ³w dobrego designu jest, aby system byÅ‚ oczywisty. To jest przeciwieÅ„stwo obciÄ…Å¼enia poznawczego i nieznanych nieznanych.

## Przyczyny zÅ‚oÅ¼onoÅ›ci

ZnajÄ…c symptomy, moÅ¼emy przejÅ›Ä‡ do przyczyn zÅ‚oÅ¼onoÅ›ci. Autor podkreÅ›la dwie gÅ‚Ã³wne przyczyny.

### ZaleÅ¼noÅ›ci

PierwszÄ… przyczynÄ… zÅ‚oÅ¼onoÅ›ci sÄ… zaleÅ¼noÅ›ci. ZaleÅ¼noÅ›Ä‡ istnieje, gdy jeden fragment kodu zaleÅ¼y od innego. Dany fragment nie moÅ¼e byÄ‡ zrozumiany i modyfikowany w izolacji.

![Graf pokazujÄ…cy wiele paczek, ktÃ³re sÄ… reprezentowane przez prostokÄ…ty poÅ‚Ä…czone strzaÅ‚kami](causes-of-complexity-dependencies.png)

One mogÄ… byÄ‡ szczegÃ³lnie problematyczne w ekosystemie JavaScript, gdzie mamy zewnÄ™trznÄ… paczkÄ™ na wszystko. Bogaty ekosystem paczek jest dobry, ale zanim zainstalujesz cokolwiek, zadaj sobie pytanie: "Czy aby na pewno potrzebujÄ™ tej paczki?". Nie popieram wymyÅ›lania koÅ‚a na nowo, ale czÄ™sto moÅ¼esz napisaÄ‡ funkcjÄ™ czy skrypt bez Å‚adowania rozdÄ™tych bibliotek.

![Mem, w ktÃ³rym folder node_modules jest ciÄ™Å¼szy niÅ¼ czarna dziura czy gwiazda neutronowa](heaviest-objects-universe-node-modules.png)

Celem dobrego designu jest decydowanie o liczbie zaleÅ¼noÅ›ci i uczynienie ich tak prostymi i oczywistymi jak to moÅ¼liwe.

### NiejasnoÅ›ci

DrugÄ… przyczynÄ… zÅ‚oÅ¼onoÅ›ci sÄ… niejasnoÅ›ci. PojawiajÄ… siÄ™, gdy kluczowa informacja nie jest oczywista. W wielkim projekcie z wieloma zaleÅ¼noÅ›ciami, Å‚atwo straciÄ‡ nad nimi rachubÄ™. NiejasnoÅ›ci pojawiajÄ… siÄ™, gdy nie jest oczywiste czy zaleÅ¼noÅ›Ä‡ istnieje.

![Graf pokazujÄ…cy wiele paczek, ktÃ³re sÄ… reprezentowane przez prostokÄ…ty poÅ‚Ä…czone strzaÅ‚kami. NiektÃ³rych paczek brakuje i sÄ… reprezentowane przez znaki zapytania](causes-of-complexity-obscurity.png)

NiespÃ³jnoÅ›ci grajÄ… takÅ¼e kluczowÄ… rolÄ™ w niejasnoÅ›ci. Nie trzymanie siÄ™ konwencji, uÅ¼ywanie nazw zmiennych dla dwÃ³ch innych celÃ³w lub posiadanie podobnych funkcji, w ktÃ³rych parametry majÄ… pomieszane pozycje - mogÄ… prowadziÄ‡ do niejasnoÅ›ci.

W poprzednich paragrafach moÅ¼na byÅ‚o zaobserwowaÄ‡ pewne analogie. ÅÄ…czÄ…c symptomy z przyczynami, otrzymujemy nastÄ™pujÄ…ce konkluzje.

- **ZaleÅ¼noÅ›ci** prowadzÄ… do **amplifikacji zmian** i wysokiego **obciÄ…Å¼enia poznawczego.**
- **NiejasnoÅ›ci** tworzÄ… **nieznane nieznane,** a takÅ¼e przyczyniajÄ… siÄ™ do **obciÄ…Å¼enia poznawczego.**

ZÅ‚oÅ¼onoÅ›Ä‡ pojawia siÄ™, poniewaÅ¼ setki tysiÄ™cy maÅ‚ych zaleÅ¼noÅ›ci i niejasnoÅ›ci nakÅ‚adajÄ… siÄ™ na siebie z czasem. Trudno jest siÄ™ pozbyÄ‡ zÅ‚oÅ¼onoÅ›ci po tym jak juÅ¼ siÄ™ zakumulowaÅ‚a. Naprawienie pojedynczej zaleÅ¼noÅ›ci lub niejasnoÅ›ci nie zrobi wiÄ™kszej rÃ³Å¼nicy.

## DziaÅ‚ajÄ…cy kod nie wystarczy

W tym momencie, mamy dobre zrozumienie zÅ‚oÅ¼onoÅ›ci. Znamy jej symptomy oraz przyczyny. Ale Å¼eby poradziÄ‡ sobie z tym problemem, potrzebujemy takÅ¼e dobrego sposobu myÅ›lenia. Autor prezentuje dwa podejÅ›cia do programowania. Dla mnie brzmiÄ… jak synonimy, ale nie bÄ™dÄ™ zmieniaÅ‚ terminologii i postaram siÄ™ je rozrÃ³Å¼niÄ‡ odpowiednio.

1. **Taktyczne programowanie** jest pierwszym podejÅ›ciem. Twoim gÅ‚Ã³wnym celem jest sprawienie, aby coÅ› dziaÅ‚aÅ‚o - dodanie funkcjonalnoÅ›ci lub naprawienie buga.
2. **Strategiczne programowanie** jest drugim podejÅ›ciem. Musisz zainwestowaÄ‡ czas, w celu poprawy projektu systemu, zamiast podÄ…Å¼aÄ‡ najkrÃ³tszÄ… Å›cieÅ¼kÄ…, aby ukoÅ„czyÄ‡ bieÅ¼Ä…cy projekt.

Drugie podejÅ›cie jest preferowanym sposobem programowania. JednakÅ¼e wymaga inwestycyjnego podejÅ›cia. Potrzebujesz czasu, Å¼eby doszlifowaÄ‡ i oczyÅ›ciÄ‡ swoje rozwiÄ…zanie. OczywiÅ›cie, czasami terminy ostateczne sÄ…... ostateczne. Nie ma czasu na refaktoryzacjÄ™ lub nawet na pisanie testÃ³w. Ale musisz uwaÅ¼aÄ‡ wykorzystujÄ…c pierwsze podejÅ›cie. Taktyczne programowanie jest krÃ³tkowzroczne. PoÅ¼yczasz czas od siebie z przyszÅ‚oÅ›ci i tworzysz dÅ‚ug techniczny. ZÅ‚oÅ¼onoÅ›ci akumulujÄ… siÄ™ szybko, szczegÃ³lnie, gdy wszyscy programujÄ… taktycznie. NaczelnÄ… zasadÄ… powinno byÄ‡ ulepszanie dÅ‚ugoterminowego projektu systemu. Dlatego powinieneÅ› spÄ™dzaÄ‡ 10 - 20% swojego czasu programowania na inwestycjach. Jest to sugestia - arbitralna liczba. Ale jest to dobra liczba na poczÄ…tek.

> SpÄ™dÅº 10 - 20% caÅ‚kowitego czasu rozwijania oprogramowania na inwestycjach.

## ModuÅ‚owy design

JesteÅ›my Å›wiadomi problemu, ale jak go zaadresowaÄ‡? JednÄ… z najskuteczniejszych strategii zarzÄ…dzania zÅ‚oÅ¼onym systemem jest podziaÅ‚ na mniejsze komponenty i wprowadzanie programistÃ³w do kaÅ¼dego z nich pojedynczo. Takie podejÅ›cie jest znane jako moduÅ‚owy design.

W moduÅ‚owym projektowaniu, system oprogramowania jest zdekomponowany na kolekcjÄ™ moduÅ‚Ã³w, ktÃ³re sÄ… relatywnie niezaleÅ¼ne. ModuÅ‚y to nie tylko klasy! SÄ… one bardziej abstrakcyjne i mogÄ… przyjÄ…Ä‡ rÃ³Å¼ne formy, takie jak:

- klasy
- podsystemy
- serwisy
- funkcje

Celem moduÅ‚owego projektowania jest minimalizowanie zaleÅ¼noÅ›ci pomiÄ™dzy moduÅ‚ami. OczywiÅ›cie te zaleÅ¼noÅ›ci muszÄ… wspÃ³Å‚dziaÅ‚aÄ‡, dlatego nie moÅ¼esz ich caÅ‚kowicie oddzieliÄ‡. Ale chcesz zminimalizowaÄ‡ te zaleÅ¼noÅ›ci.

Jak wyglÄ…da anatomia moduÅ‚u? ModuÅ‚ skÅ‚ada siÄ™ z dwÃ³ch czÄ™Å›ci: interfejsu i implementacji. **Interfejs** zawiera wszystko co programista musi wiedzieÄ‡, aby uÅ¼yÄ‡ danego moduÅ‚u. **Implementacja** zawiera kod, ktÃ³ry speÅ‚nia obietnicÄ™ zÅ‚oÅ¼onÄ… przez interfejs.

![Schemat w formie prostokÄ…ta. CaÅ‚y prostokÄ…t jest moduÅ‚em. Interfejs jest maÅ‚ym, kreskowanym prostokÄ…tem na gÃ³rze. Reszta to implementacja](module-anatomy.png)

Interfejs opisuje _co_ moduÅ‚ robi, ale _nie jak_ to zrobiÄ‡. Implementacja odpowiada na drugie pytanie.

<Callout variant="info">

**Abstrakcja**  
Abstrakcja to uproszczony obraz jednostki, opuszczajÄ…ca nieistotne detale. Abstrakcje sÄ… przydatne, poniewaÅ¼ upraszczajÄ… nasze myÅ›lenie i manipulacje zÅ‚oÅ¼onymi rzeczami.

</Callout>

Termin abstrakcji jest blisko zwiÄ…zany z moduÅ‚owym projektowaniem. MoÅ¼emy poÅ‚Ä…czyÄ‡ definicjÄ™ abstrakcji z moduÅ‚ami - kaÅ¼dy moduÅ‚ dostarcza abstrakcji w formie swojego interfejsu.

## GÅ‚Ä™bokie moduÅ‚y kontra pÅ‚ytkie moduÅ‚y

Teraz przechodzimy do ciekawych rzeczy. Mam nadziejÄ™, Å¼e poprzednie sekcje byÅ‚y takÅ¼e ciekawe, ale ten powinien byÄ‡ w szczegÃ³lnoÅ›ci (a jeÅ¼eli byÅ‚y nudne, moÅ¼e rozbudzÄ™ twojÄ… ciekawoÅ›Ä‡). Autor stwierdza, Å¼e najlepsze moduÅ‚y powinny byÄ‡ gÅ‚Ä™bokie - powinny mieÄ‡ duÅ¼o funkcjonalnoÅ›ci za prostym interfejsem.

![GÅ‚Ä™bokie moduÅ‚y sÄ… reprezentowane za pomocÄ… podÅ‚uÅ¼nego prostokÄ…ta o wÄ…skim interfejsie. PÅ‚ytkie moduÅ‚y sÄ… reprezentowane przez niski prostokÄ…t o szerokim interfejsie](deep-modules-vs-shallow-modules.png)

Podoba mi siÄ™ ta prosta, graficzna interpretacja, ktÃ³rÄ… przerysowaÅ‚em z ksiÄ…Å¼ki. PodÅ‚uÅ¼ny prostokÄ…t reprezentuje gÅ‚Ä™bokie moduÅ‚y - interfejs jest wÄ…ski, ale przykrywa wiele funkcjonalnoÅ›ci pod spodem. Z drugiej strony, mamy pÅ‚ytkie moduÅ‚y. Ich interfejs jest szeroki z niewielkÄ… funkcjonalnoÅ›ciÄ…. PÅ‚ytkie moduÅ‚y to nasza pierwsza czerwona flaga.

<Callout variant="danger">

**PÅ‚ytkie moduÅ‚y** ğŸš©  
PÅ‚ytki moduÅ‚ to taki, ktÃ³rego interfejs jest skomplikowany relatywnie do funkcjonalnoÅ›ci, ktÃ³rÄ… dostarcza. PÅ‚ytkie moduÅ‚y nie pomagajÄ… za bardzo w walce przeciwko zÅ‚oÅ¼onoÅ›ci, poniewaÅ¼ ich korzyÅ›ci sÄ… negowane przez koszt nauki i uÅ¼ywania ich interfejsÃ³w.

</Callout>

JeÅ¼eli wolisz ekonomicznÄ… analogiÄ™, moÅ¼emy rozpatrywaÄ‡ moduÅ‚y na zasadzie kosztÃ³w i korzyÅ›ci. KorzyÄ‡ moduÅ‚y leÅ¼y w jego funkcjonalnoÅ›ci, natomiast kosztem jest jego interfejs.

## Classistis

Istnieje choroba, ktÃ³ra zatruwa systemy wieloma pÅ‚ytkimi moduÅ‚ami i nazywa siÄ™ "classistis". W takich systemach, programiÅ›ci sÄ… zachÄ™cani do minimalizowania iloÅ›ci funkcjonalnoÅ›ci w kaÅ¼dej z nowych klas. Pewnie, klasy same w sobie sÄ… jasne, ale system jako caÅ‚oÅ›Ä‡ juÅ¼ nie jest. Naszym celem powinna byÄ‡ minimalizacja ogÃ³lnej zÅ‚oÅ¼onoÅ›ci systemu.

Java ma podobny problem. Potrzebujesz skomplikowanego szablonu kodu z wieloma importami, Å¼eby otworzyÄ‡ zwykÅ‚y plik.

```java title="Otwieranie pliku w Javie"
import static java.nio.file.StandardOpenOption.*;
import java.nio.file.*;
import java.io.*;

public class LogFileTest {

  public static void main(String[] args) {

    // Convert the string to a
    // byte array.
    String s = "Hello World! ";
    byte data[] = s.getBytes();
    Path p = Paths.get("./logfile.txt");

    try (OutputStream out = new BufferedOutputStream(
      Files.newOutputStream(p, CREATE, APPEND))) {
      out.write(data, 0, data.length);
    } catch (IOException x) {
      System.err.println(x);
    }
  }
}
```

JavaScript ma swoje problemy, ale jestem wdziÄ™czny, Å¼e Brendan Eich, stworzyÅ‚ go podobnym do Javy, ale "nie za bardzo".

## Jak pogÅ‚Ä™biÄ‡ moduÅ‚y?

Wiemy, Å¼e pÅ‚ytkie moduÅ‚y sÄ… problematyczne, wiÄ™c jak je pogÅ‚Ä™biÄ‡? Problem sprowadza siÄ™ do zestawienia ogÃ³lnoÅ›ci i specjalizacji. Nadmierna specjalizacja moÅ¼e byÄ‡ najbardziej jasnÄ… przyczynÄ… zÅ‚oÅ¼onoÅ›ci oprogramowania. Podobnie moÅ¼esz skomplikowaÄ‡ swoje Å¼ycie. Bycie specjalistÄ… jest dobre (szczegÃ³lnie dla twojego portfela), ale moÅ¼esz mieÄ‡ problemy komunikacyjne z innymi. JeÅ¼eli chcesz skutecznie wspÃ³Å‚pracowaÄ‡ z pisarzami, projektantami czy testerami, powinieneÅ› znaÄ‡ przynajmniej podstawy w tych dziedzinach. Istnieje znana metafora umiejÄ™tnoÅ›ci w ksztaÅ‚cie litery "T", ktÃ³ra zgrabnie to ilustruje, ale zagÅ‚Ä™biam siÄ™ w dygresje. WrÃ³Ä‡my do moduÅ‚Ã³w.

## Ukrywanie i wyciek informacji

Autor wspomina ukrywanie informacji jako jednÄ… z najwaÅ¼niejszych technik osiÄ…gania gÅ‚Ä™bokich moduÅ‚Ã³w. **Ukrywanie informacji** oznacza, Å¼e powinniÅ›my redukowaÄ‡ iloÅ›Ä‡ informacji potrzebnych do pracy z danym moduÅ‚em. Wiedza zawarta w implementacji moduÅ‚u nie powinna pojawiaÄ‡ siÄ™ w jego interfejsie i byÄ‡ wystawiona innym moduÅ‚om. MoÅ¼emy tu wykorzystaÄ‡ analogiÄ™ czarnej skrzynki - ukrywanie informacji to traktowanie kaÅ¼dego moduÅ‚u jak nieprzezroczystej, czarnej skrzynki. Nie musisz wiedzieÄ‡ co siÄ™ dzieje wewnÄ…trz, aby go wykorzystaÄ‡. Ukrywanie informacji redukuje zÅ‚oÅ¼onoÅ›Ä‡ na dwa sposoby:

1. Upraszcza interfejs moduÅ‚u.
2. UÅ‚atwia ewolucje systemu.

SÅ‚abo zaprojektowane, niemoduÅ‚owe komponenty czÄ™sto wymagajÄ… przypadkowych, dodatkowych informacji, ujawniajÄ…c wewnÄ™trzne dziaÅ‚anie. Te dodatkowe informacje to forma wycieku. Wyjawiasz detale implementacyjne do uÅ¼ytkownika moduÅ‚u.

<Callout variant="danger">

**Wyciek informacji** ğŸš©  
Wyciek informacji pojawia siÄ™, gdy ta sama wiedza jest uÅ¼yta w wielu miejscach, jak w dwÃ³ch rÃ³Å¼nych klasach, ktÃ³re rozumiejÄ… format konkretnego typu pliku.

</Callout>

Wyciek informacji to krytyczna czerwona flaga w projektowaniu oprogramowania. Rozwijanie wraÅ¼liwoÅ›ci na wyciek informacji jest jednÄ… z najbardziej wartoÅ›ciowych umiejÄ™tnoÅ›ci jakie projektant oprogramowania moÅ¼e posiÄ…Å›Ä‡.

## WartoÅ›ci domyÅ›lne

WartoÅ›ci domyÅ›lne ilustrujÄ… zasadÄ™, Å¼e interfejsy powinny byÄ‡ zaprojektowany w sposÃ³b, aby najczÄ™stszy przypadek byÅ‚ tak prosty jak to moÅ¼liwe.

<Callout variant="danger">

**NierozsÄ…dne wartoÅ›ci domyÅ›lne** ğŸš©  
JeÅ¼eli API dla najczÄ™stszego przypadku zmusza uÅ¼ytkownikÃ³w, aby uczyli siÄ™ o rzadkich funkcjonalnoÅ›ciach, zwiÄ™ksza to obciÄ…Å¼enie poznawcze uÅ¼ytkownikÃ³w, ktÃ³rzy nie potrzebujÄ… tych funkcjonalnoÅ›ci.

</Callout>

PokaÅ¼Ä™ przykÅ‚ad z mojego repozytorium. W kodzie, mam funkcje pomocnicze do procesowania plikÃ³w MDX (format moich wpisÃ³w na blogu).

```ts title="PrzykÅ‚ad rozsÄ…dnych wartoÅ›ci domyÅ›lnych" highlight={[4, 5]}
export async function getMDXes<Type extends MDXTypes>(
  page: Extract<Pages, (typeof LINKS)['blog' | 'portfolio']>,
  lang: Locale,
  number: number | 'all' = 'all',
  sort: 'asc' | 'desc' | 'none' = 'none'
) {
  // CiaÅ‚o funkcji
}
```

Funkcja `getMDXes()` zwraca pliki MDX dla konkretnej strony. MogÄ™ uzyskaÄ‡ wiele takich plikÃ³w posortowanych po dacie. Jak widzisz, wykorzystuje dwie wartoÅ›ci domyÅ›lne. Przez wiÄ™kszoÅ›Ä‡ czasu, chcÄ™ wszystkie, nieposortowane pliki, wiÄ™c ma to sens.

## ModuÅ‚y ogÃ³lnego przeznaczenia

JeÅ¼eli nadmierna specjalizacja powoduje zÅ‚oÅ¼onoÅ›Ä‡, powinniÅ›my jej unikaÄ‡. Powinno mieÄ‡ to intuicyjny sens - kilka, uniwersalnych metod jest prostszych w uÅ¼yciu. Redukuje to obciÄ…Å¼enie poznawcze. JednakÅ¼e, jak z wieloma rzeczami, warto dÄ…Å¼yÄ‡ do balansu. Implementowanie czegoÅ›, co jest za bardzo ogÃ³lne moÅ¼e sÅ‚abo rozwiÄ…zywaÄ‡ problem, ktÃ³ry masz dziÅ›. Dlatego celem powinno byÄ‡ implementowanie nowych moduÅ‚Ã³w, ktÃ³re sÄ… âœ¨niecoâœ¨ ogÃ³lnego przeznaczenia. MoÅ¼na to rozumieÄ‡ tak, Å¼e funkcjonalnoÅ›Ä‡ moduÅ‚u powinna odzwierciedlaÄ‡ twoje aktualne potrzeby, ale interfejs nie.

## UsuÅ„ przypadki szczegÃ³lne

Przypadki brzegowe mogÄ… siÄ™ ukrywaÄ‡ w ciaÅ‚ach funkcji, zwiÄ™kszajÄ…c specjalizacjÄ™ kodu. Takie kod jest wypeÅ‚niony instrukcjami warunkowymi, utrudniajÄ…cymi jego zrozumienie i czyniÄ…cymi go podatnymi na bÅ‚Ä™dy. "Dobra Mateusz, ale jak mam w takim razie obsÅ‚ugiwaÄ‡ takie przypadki?". Projektowanie kodu, gdzie standardowy przypadek automatycznie obsÅ‚uguje przypadki brzegowe powinno pomÃ³c. Nie zawsze jest to moÅ¼liwe, ale powinniÅ›my je eliminowaÄ‡ tam, gdzie to moÅ¼liwe.

## Razem czy osobno

"BÄ™dÄ… ze sobÄ… czy nie?". Dobry romans nie moÅ¼e siÄ™ obejÅ›Ä‡ bez tej techniki opowiadania historii. MoÅ¼e zÅ‚apaÄ‡ nas emocjonalnie i przykuÄ‡ do ekranu. Kod teÅ¼ potrafi przykuÄ‡ do ekranu, ale bez tego emocjonalnego bagaÅ¼u (no chyba, Å¼e jest popoÅ‚udniowy piÄ…tek, a ty prÃ³bujesz naprawiÄ‡ produkcjÄ™). JednakÅ¼e, podobnie jak w dobrym romansie, dobry kod powinien wywoÅ‚aÄ‡ podobne pytanie - powinni byÄ‡ razem czy osobno? NiektÃ³re wskazÃ³wki ilustrujÄ…, Å¼e pewne fragmenty kodu sÄ… powiÄ…zane.

- **PoÅ‚Ä…cz razem jeÅ¼eli dzielÄ… informacje.** Oddzielenie sprawia, Å¼e trudniej jest programistom widzieÄ‡ komponenty w tym samym momencie czy nawet byÄ‡ Å›wiadomym ich istnienia.
- **PoÅ‚Ä…cz razem jeÅ¼eli upraszcza to interfejs.** Kiedy klasy lub metody dzielÄ… informacje, zbliÅ¼ je do siebie, aby poprawiÄ‡ czytelnoÅ›Ä‡. Kod stanie siÄ™ prostszy i krÃ³tszy.
- **PoÅ‚Ä…cz razem, aby wyeliminowaÄ‡ duplikacjÄ™.** Kiedy dwa lub wiÄ™cej moduÅ‚Ã³w zostaje poÅ‚Ä…czonych w jeden, jest moÅ¼liwe, aby zdefiniowaÄ‡ interfejs dla nowego moduÅ‚u, ktÃ³ry jest prostszy lub Å‚atwiejszy w uÅ¼yciu niÅ¼ ten oryginalny.

<Callout variant="danger">

**Duplikacja kodu** ğŸš©  
JeÅ¼eli ten sam fragment kodu (albo prawie ten sam) pojawia siÄ™ raz za razem, jest to czerwona flaga, oznaczajÄ…ca, Å¼e brakuje odpowiednich abstrakcji.

</Callout>

- **Rozdziel kod ogÃ³lnego i specjalnego przeznaczenia.** JeÅ¼eli zauwaÅ¼ysz jakiÅ› wzorzec w kodzie powtÃ³rzony wielokrotnie, sprawdÅº czy jesteÅ› w stanie wyeliminowaÄ‡ powtÃ³rzenie.

<Callout variant="danger">

**Mieszanie kodu ogÃ³lnego i specjalnego przeznaczenia** ğŸš©  
Ta czerwona flaga pojawia siÄ™, gdy mechanizm ogÃ³lnego przeznaczenia zawiera takÅ¼e wyspecjalizowany kod dla konkretnego przypadku tego mechanizmu. Komplikuje to ten mechanizm i tworzy wyciek informacji pomiÄ™dzy mechanizmem, a konkretnym przypadkiem - przyszÅ‚e modyfikacje tego przypadku bÄ™dÄ… najprawdopodobniej wymagaÅ‚y zmian w podstawowym mechanizmie.

</Callout>

## Dzielenie i Å‚Ä…czenie metod

> Pierwsza zasada dotyczÄ…ca konstruowania funkcji jest taka, Å¼e powinny byÄ‡ maÅ‚e. Druga zasada mÃ³wi, Å¼e powinny byÄ‡ mniejsze, niÅ¼ sÄ….
>
> &mdash; <cite>Robert C. Martin</cite>

Prawdopodobnie znasz "wujka Boba" i jego przemyÅ›lenia dotyczÄ…ce funkcji z "Czystego kodu". Klasyka. No i... zamierzam z niÄ… polemizowaÄ‡. W zasadzie, John Ousterhou polemizuje z niÄ…. MyÅ›li on, Å¼e dÅ‚ugoÅ›Ä‡ sama w sobie jest rzadko dobrym powodem, aby podzieliÄ‡ metodÄ™. PodziaÅ‚ metody wprowadza dodatkowe interfejsy, ktÃ³re zwiÄ™kszajÄ… zÅ‚oÅ¼onoÅ›Ä‡. Dla mnie ma to sens. Jest to ciekawa alternatywa dla perspektywy "wujka". KrÃ³tkie funkcje sÄ… ogÃ³lnie Å‚atwiejsze do zrozumienia - wiadomo. JednakÅ¼e naszym celem powinno byÄ‡ redukowanie ogÃ³lnej zÅ‚oÅ¼onoÅ›ci systemu. JeÅ¼eli funkcje sÄ… zbyt maÅ‚e, tracÄ… niezaleÅ¼noÅ›Ä‡, sÄ… poÅ‚Ä…czone i muszÄ… byÄ‡ czytane i rozumiane razem.

<Callout variant="danger">

**ZaleÅ¼ne metody** ğŸš©  
Powinno daÄ‡ siÄ™ zrozumieÄ‡ kaÅ¼dÄ… z metod niezaleÅ¼nie. JeÅ¼eli nie moÅ¼esz zrozumieÄ‡ implementacji jednej metody bez zrozumienia implementacji innej, jest to czerwona flaga.

</Callout>

Decyzja, aby podzieliÄ‡ lub zÅ‚Ä…czyÄ‡ moduÅ‚y powinna bazowaÄ‡ na zÅ‚oÅ¼onoÅ›ci. Wybierz strukturÄ™, ktÃ³ra najlepiej ukryje informacje, bÄ™dzie miaÅ‚a jak najmniej zaleÅ¼noÅ›ci i gÅ‚Ä™bokie interfejsy. Istnieje kilka sposobÃ³w na efektywny podziaÅ‚ metod.

### WyodrÄ™bnienie podzadania

Najlepszym sposobem na podziaÅ‚ metody jest wydzielenie z niej podzadania do oddzielnej metody. W wyniku takiego podziaÅ‚u mamy metodÄ™ "dziecko" z podzadaniem i metodÄ™ "rodzica" przypominajÄ…cÄ… oryginalnÄ… metodÄ™. Rodzic wywoÅ‚uje dziecko. Taki podziaÅ‚ nie zmienia interfejsu. Interfejs nowej metody-rodzica jest taki sam jak oryginalnej metody.

![Na zdjÄ™ciu sÄ… trzy prostokÄ…ty. KaÅ¼dy prostokÄ…t reprezentuje moduÅ‚. Jeden jest duÅ¼y, a dwa progresywnie mniejsze. Dwa mniejsze sÄ… poÅ‚Ä…czone ze sobÄ… strzaÅ‚kÄ…. Ich Å‚Ä…czna powierzchnia jest podobna do powierzchni tego wiÄ™kszego. StrzaÅ‚ki - reprezentujÄ…ce wywoÅ‚ujÄ…cych - wskazujÄ… na oba prostokÄ…ty z gÃ³ry](extracting-a-subtask.png)

Ponownie wykorzystam przykÅ‚ad z mojego repozytorium.

```ts title="PrzykÅ‚ad wydzielenia podzadania" highlight={[11]}
export async function getMDXes<Type extends MDXTypes>(
  page: Extract<Pages, (typeof LINKS)['blog' | 'portfolio']>,
  lang: Locale,
  number: number | 'all' = 'all',
  sort: 'asc' | 'desc' | 'none' = 'none'
) {
  const slugs = await getMDXSlugs(page)
  const mdxes = await Promise.all(
    slugs.map((slug) => getCachedMDX<Type>(page, slug, lang))
  )
  const sorted = sort === 'none' ? mdxes : sortMDXes<Type>(mdxes, sort)
  const filtered =
    number === 'all' ? sorted : sorted.filter((_, index) => index < number)

  return filtered
}
```

Funkcja `getMDXes()` zwraca pliki MDX dla konkretnej strony. MogÄ™ uzyskaÄ‡ wiele plikÃ³w posortowanych po dacie. Na poczÄ…tku, caÅ‚a logika - Å‚Ä…cznie z sortowaniem - byÅ‚a wewnÄ…trz tej jednej funkcji. WyodrÄ™bniÅ‚em to zadanie z funkcji-rodzica do innej. Nowa metoda jest krÃ³tsza, Å‚atwiejsza do przeczytania i Å‚atwiej niÄ… zarzÄ…dzaÄ‡. Interfejs pozostaje bez zmian.

### Dwie oddzielne metody

Drugim sposobem na rozbicie metody, jest podziaÅ‚ na dwie oddzielne metody, gdzie kaÅ¼da z nich jest widoczna dla wywoÅ‚ujÄ…cych oryginalnej metody. Ma to sens jeÅ¼eli oryginalna metoda ma bardzo zawiÅ‚y interfejs, poniewaÅ¼ prÃ³bowaÅ‚a robiÄ‡ wiele, niepowiÄ…zanych ze sobÄ… rzeczy. JeÅ¼eli wykonujesz taki podziaÅ‚, interfejs kaÅ¼dej z metody powinien byÄ‡ prostszy niÅ¼ interfejs oryginalnej metody.

![Na zdjÄ™ciu sÄ… dwa prostokÄ…ty. KaÅ¼dy prostokÄ…t reprezentuje moduÅ‚. MajÄ… podobnÄ… wielkoÅ›Ä‡ i pole. StrzaÅ‚ki - reprezentujÄ…ce wywoÅ‚ujÄ…cych - wskazujÄ… na oba prostokÄ…ty z gÃ³ry](two-separate-methods.png)

### Wiele metod

Tu trzeba byÄ‡ ostroÅ¼nym. JeÅ¼eli dzielisz metodÄ™ w ten sposÃ³b, ryzykujesz, Å¼e skoÅ„czysz z wieloma pÅ‚ytkimi metodami. MoÅ¼esz rozwaÅ¼yÄ‡ taki podziaÅ‚, ale powinieneÅ› uwzglÄ™dniÄ‡ czy to upraszcza rzeczy dla wywoÅ‚ujÄ…cych.

![Na zdjÄ™ciu jest wiele prostokÄ…tÃ³w. KaÅ¼dy prostokÄ…t reprezentuje moduÅ‚. MajÄ… rÃ³Å¼ne wielkoÅ›ci i powierzchnie. StrzaÅ‚ki - reprezentujÄ…ce wywoÅ‚ujÄ…cych - wskazujÄ… na kaÅ¼dy z nich z gÃ³ry](multiple-methods.png)

## Wybieranie nazw

Docieramy do innego wielkiego problemu w inÅ¼ynierii oprogramowania - nazywania rzeczy. Wybieranie nazw dla zmiennych, metod i innych jednostek jest jednym z najbardziej niedocenianych aspektÃ³w dobrego oprogramowania. Dobre nazwy sÄ… formÄ… dokumentacji - sprawiajÄ…, Å¼e kod jest Å‚atwiejszy do zrozumienia. Nie powinieneÅ› zadowalaÄ‡ siÄ™ nazwami, ktÃ³re sÄ… "wystarczajÄ…co blisko". PoÅ›wiÄ™Ä‡ wiÄ™cej czasu na wybÃ³r Å›wietnych nazw, ktÃ³re sÄ… precyzyjne, jednoznaczne i intuicyjne. Ja to zrobiÄ‡? Przekonajmy siÄ™.

### StwÃ³rz obraz

"Obraz jest wart wiÄ™cej niÅ¼ tysiÄ…c sÅ‚Ã³w". Jest sporo prawdy w tej starej frazie. Niestety nie moÅ¼emy uÅ¼ywaÄ‡ zdjÄ™Ä‡ lub emoji jak nazw zmiennych (a przynajmniej nie w JS/TS). A szkoda, bo pszczoÅ‚a jest kojarzona z brzÄ™czeniem i mogÅ‚aby symbolizowaÄ‡ aktualizacje na moim blogu. JednakÅ¼e wybierajÄ…c nazwy moÅ¼emy stworzyÄ‡ obraz z umyÅ›le czytelnika. Dobra nazwa przekazuje wiele informacji o jednostce pod spodem. "JeÅ¼eli ktoÅ› zobaczy tÄ™ nazwÄ™ w izolacji, czy bÄ™dzie w stanie zgadnÄ…Ä‡ do czego siÄ™ odnosi?". Tego typu pytania mogÄ… pomÃ³c ci w malowaniu jasnego obrazu. MoÅ¼esz myÅ›leÄ‡ o nazwach jako o formie abstrakcji - czy dostarczajÄ… uproszczonego sposobu myÅ›lenia o bardziej zÅ‚oÅ¼onej jednostce, leÅ¼Ä…cej pod spodem.

### Nazwy powinny byÄ‡ precyzyjne

Dobra nazwa ma dwie cechy: spÃ³jnoÅ›Ä‡ i precyzjÄ™. I z tymi dwoma cechami wiÄ…Å¼Ä… siÄ™ dwie czerwone flagi.

<Callout variant="danger">

**Mglista nazwa** ğŸš©  
JeÅ¼eli nazwa zmiennej czy metody jest wystarczajÄ…co szeroka, aby odnosiÄ‡ siÄ™ do wielu rÃ³Å¼nych rzeczy, wÃ³wczas nie przekazuje programiÅ›cie zbyt wielu informacji o jednostce do ktÃ³rej siÄ™ odnosi i moÅ¼e zostaÄ‡ bÅ‚Ä™dnie uÅ¼yta.

</Callout>

<Callout variant="danger">

**Trudna do wybrania nazwa** ğŸš©  
JeÅ¼eli trudno jest wybraÄ‡ prostÄ… nazwÄ™ dla zmiennej czy metody, ktÃ³ra tworzyÅ‚aby jasny obraz obiektu leÅ¼Ä…cego pod spodem, jest to wskazÃ³wka, Å¼e ten obiekt moÅ¼e nie mieÄ‡ czystego projektu.

</Callout>

### Konsekwentnie uÅ¼ywaj nazw

Skoro juÅ¼ wymieniamy rzeczy, spÃ³jnoÅ›Ä‡ ma trzy wymagania:

1. Zawsze uÅ¼ywaj nazwy zwyczajowej dla danego celu.
2. Nigdy nie uÅ¼ywaj nazwy zwyczajowej dla celu innego niÅ¼ dany.
3. Upewnij siÄ™, Å¼e cel jest na tyle wÄ…ski, Å¼e wszystkie zmienne o danej nazwie majÄ… takie samo zachowanie.

SpÃ³jne nazewnictwo redukuje jeden symptom zÅ‚oÅ¼onoÅ›ci - obciÄ…Å¼enie poznawcze. Kiedy czytelnik widziaÅ‚ nazwÄ™ w danym kontekÅ›cie, moÅ¼e wykorzystaÄ‡ tÄ™ wiedzÄ™ i natychmiast mieÄ‡ zaÅ‚oÅ¼enia dotyczÄ…ce innego kontekstu.

### Unikaj dodatkowych sÅ‚Ã³w

KaÅ¼de sÅ‚owo w nazwie powinno dostarczaÄ‡ przydatnych informacji - sÅ‚owa, ktÃ³re nie pomagajÄ… wyklarowaÄ‡ znaczenia zmiennej tylko wprowadzajÄ… nieÅ‚ad. Jednym, popularnym bÅ‚Ä™dem jest dodawanie ogÃ³lnych rzeczownikÃ³w takich jak "array" czy "object" do nazwy. Sam byÅ‚em tego winien.

![ZdjÄ™cie pokazuje kilka nazw zmiennych i klas zawierajÄ…cych dodatkowe, skreÅ›lone sÅ‚owa takie jak fileObject. Jest takÅ¼e przykÅ‚ad notacji wÄ™gierskiej](avoid-extra-words.png)

Notacja wÄ™gierska jest konwencjÄ… dla zmiennych, gdzie jej nazwa sugeruje typ, wykorzystujÄ…c prefiks nazwany "wskaÅºnikiem typu". WczeÅ›ni programiÅ›ci C/C++ wykorzystywali jÄ…, aby identyfikowaÄ‡ typy zmiennych. JednakÅ¼e konwencja ta jest przestarzaÅ‚a we wspÃ³Å‚czesnych silnie typowanych jÄ™zykach, jak TypeScript czy Python. A zatem, Polak, WÄ™gier, nie dwa bratanki, najwyraÅºniej.

Czytelnicy powinni decydowaÄ‡ o czytelnoÅ›ci, a nie pisarz kodu - podobnie do [pisania po polsku](/pl/blog/the-craft-of-writing). JeÅ¼eli piszesz kod z krÃ³tkimi nazwami zmiennych, a ludziom ktÃ³rzy go czytajÄ… wydaje siÄ™ prosty do zrozumienia - w porzÄ…dku.

## PomyÅ›l dwa razy

Wszystko o czym piszÄ™ moÅ¼e byÄ‡ podsumowane tÄ… jednÄ… sentencjÄ…, oznaczajÄ…cÄ…, Å¼e powinieneÅ› myÅ›leÄ‡ wiÄ™cej i pisaÄ‡ mniej - w erze AI i kodujÄ…cych agentÃ³w, jest to szczegÃ³lnie istotne.

> Uzyskasz znacznie lepszy rezultat jeÅ¼eli rozwaÅ¼ysz wiele opcji przed podjÄ™ciem kaÅ¼dej, waÅ¼nej projektowej decyzji.
>
> &mdash; <cite>John Ousterhout, "A Philosophy of Software Design"</cite>
